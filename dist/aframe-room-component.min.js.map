{"version":3,"file":"aframe-room-component.min.js","mappings":"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","sources":["webpack://aframe-room-component/webpack/universalModuleDefinition","webpack://aframe-room-component/./index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","AFRAME.registerSystem('building',{\r\n\t\r\n\treexamineBuilding:function(){\r\n\t\t\r\n\t\t//console.log(\" = REEVALUATION REQUESTED...\");\r\n\t\t\r\n\t\tvar buildingSelf = this;\r\n\t\tvar HAIR = 0.0001;\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t/*\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\thttps://github.com/omgitsraven/aframe-room-component\r\n\t\tv0.4.2\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tOPTIMIZATION:\r\n\t\t\r\n\t\tcurrently, the entire building is getting re-generated from scratch any time anything in it changes.\r\n\t\tobviously this is wasteful, but:\r\n\t\t- this library isn't particularly likely to be used in a context where these properties will be changing at runtime (at least outside of debugging)\r\n\t\t- right now I am more concerned with getting it out the door than making it perfect anyway\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tPLANNED FEATURES TO COME (in order):\r\n\t\t- greater control over UV generation\r\n\t\t- automatic collision assignment\r\n\t\t- doors lifted above the ground (i.e. windows)\r\n\t\t- accept a shape to be extruded around a doorhole to make a doorframe (& around a floor to make a baseboard)\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tKNOWN ISSUES (with no obvious solution that would preserve ease of use):\r\n\t\t- floor/ceiling triangulation is not controllable (and therefore varying wall verticality is nearly useless unless slope is consistent)\r\n\t\t- doorhole parenting is always level to the horizon even on slope-floored walls\r\n\t\t- the setTimeout thing results in a one-frame flash of invisible walls: is it worth it? (is there a smarter thing to listen for, maybe?)\r\n\t\t\r\n\t\tISSUES THAT COULD THEORETICALLY BE FIXED BUT DON'T SEEM WORTH THE TROUBLE:\r\n\t\t- walls are internally rearranged to always wind CW, which means wall parenting will point towards the \"previous\" wall if you entered them in CCW order\r\n\t\t\r\n\t\t*/\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tfunction flipGeom(geom){\r\n\t\t\tconst indices = geom.getIndex().array;\r\n\t\t\tfor (let i = 0; i < indices.length; i += 3) {\r\n\t\t\t\tconst tempIndex = indices[i + 2];\r\n\t\t\t\tindices[i + 2] = indices[i + 1];\r\n\t\t\t\tindices[i + 1] = tempIndex;\r\n\t\t\t}\r\n\r\n\t\t\tgeom.getIndex().needsUpdate = true;\r\n\t\t}\r\n\t\t\r\n\t\tfunction makeUvsForGeom(geom,callback){\r\n\t\t\tvar allUVs = [];\r\n\t\t\tfor(var faceVertIndex=0; faceVertIndex<geom.index.array.length; faceVertIndex++){\r\n\t\t\t\tvar vertexIndex = geom.index.array[faceVertIndex];\r\n\t\t\t\tvar vertex = new THREE.Vector3(\r\n\t\t\t\t\tgeom.attributes.position.getX(vertexIndex),\r\n\t\t\t\t\tgeom.attributes.position.getY(vertexIndex),\r\n\t\t\t\t\tgeom.attributes.position.getZ(vertexIndex)\r\n\t\t\t\t);\r\n\t\t\t\tvar uv = callback(vertex,faceVertIndex%3);\r\n\t\t\t\tallUVs[vertexIndex*2+0] = uv[0];\r\n\t\t\t\tallUVs[vertexIndex*2+1] = uv[1];\r\n\t\t\t}\r\n\t\t\tgeom.setAttribute('uv',new THREE.BufferAttribute(new Float32Array(allUVs),2));\r\n\t\t\tgeom.uvsNeedUpdate = true;\r\n\t\t\t\r\n\t\t}\r\n\t\tfunction makePlaneUvs(geom,uKey,vKey,uMult,vMult){\r\n\t\t\tmakeUvsForGeom(geom,function(pt){\r\n\t\t\t\treturn [\r\n\t\t\t\t\tpt[uKey]*uMult,\r\n\t\t\t\t\tpt[vKey]*vMult\r\n\t\t\t\t];\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tfunction finishGeom(geom){\r\n\t\t\tgeom.computeVertexNormals();\r\n\t\t\t// are these necessary?\r\n\t\t\tgeom.computeBoundingBox();\r\n\t\t\tgeom.computeBoundingSphere();\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tfunction getUnsortedRoomWallArray(roomEl){\r\n\t\t\tvar walls=[];\r\n\t\t\tfor(var roomChildNodeIndex=0; roomChildNodeIndex<roomEl.children.length; roomChildNodeIndex++){\r\n\t\t\t\tvar roomChildNode = roomEl.children[roomChildNodeIndex];\r\n\t\t\t\tif (roomChildNode.components.wall) walls.push(roomChildNode);\r\n\t\t\t}\r\n\t\t\treturn walls;\r\n\t\t}\r\n\t\t\r\n\t\tfunction getRoomWallArray(roomEl){\r\n\t\t\t\r\n\t\t\t// the results of this not being saved anywhere is super wasteful,\r\n\t\t\t// but, see above; not worth worrying about yet\r\n\t\t\t\r\n\t\t\tvar isOutside = roomEl.components.room.data.outside;\r\n\t\t\t\r\n\t\t\tvar walls = getUnsortedRoomWallArray(roomEl);\r\n\t\t\t\r\n\t\t\tvar cwSum=0;\r\n\t\t\tfor(var wallIndex=0; wallIndex<walls.length; wallIndex++){\r\n\t\t\t\tvar curWallNode = walls[wallIndex];\r\n\t\t\t\tvar nextWallNode = walls[(wallIndex+1)%walls.length];\r\n\t\t\t\tvar curWallPos = curWallNode.components.position.data;\r\n\t\t\t\tvar nextWallPos = nextWallNode.components.position.data;\r\n\t\t\t\t\r\n\t\t\t\tcwSum += (nextWallPos.x - curWallPos.x) * (nextWallPos.z + curWallPos.z);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar shouldReverse = false;\r\n\t\t\tif (cwSum > 0) shouldReverse = !shouldReverse;\r\n\t\t\tif (isOutside) shouldReverse = !shouldReverse;\r\n\t\t\tif (shouldReverse) walls.reverse();\r\n\t\t\t\r\n\t\t\treturn walls;\r\n\t\t\t\r\n\t\t}\r\n\t\tfunction getNextWallEl(wallEl){\r\n\t\t\tvar wallList = getRoomWallArray(wallEl.parentNode);\r\n\t\t\tvar curWallIndex = wallList.indexOf(wallEl);\r\n\t\t\treturn wallList[(curWallIndex+1)%wallList.length];\r\n\t\t}\r\n\t\t\r\n\t\tvar worldWallPos = new THREE.Vector3();\r\n\t\tvar worldNextPos = new THREE.Vector3();\r\n\t\tvar worldLinkPos = new THREE.Vector3();\r\n\t\tfunction moveForLink(doorholeEl,doorlinkEl){\r\n\t\t\t\r\n\t\t\tvar holeWallEl = doorholeEl.parentNode;\r\n\t\t\tvar nextWallEl = getNextWallEl(holeWallEl);\r\n\t\t\tif (!nextWallEl) return;\r\n\t\t\t\r\n\t\t\tholeWallEl.object3D.getWorldPosition(worldWallPos);\r\n\t\t\tnextWallEl.object3D.getWorldPosition(worldNextPos);\r\n\t\t\tdoorlinkEl.object3D.getWorldPosition(worldLinkPos);\r\n\t\t\t\r\n\t\t\tvar linkGapX = worldLinkPos.x - worldWallPos.x;\r\n\t\t\tvar linkGapZ = worldLinkPos.z - worldWallPos.z;\r\n\t\t\t\r\n\t\t\tvar wallGapX = worldNextPos.x - worldWallPos.x;\r\n\t\t\tvar wallGapZ = worldNextPos.z - worldWallPos.z;\r\n\t\t\tvar wallAng = Math.atan2(wallGapZ,wallGapX);\r\n\t\t\tvar wallLength = Math.sqrt(wallGapX*wallGapX + wallGapZ*wallGapZ);\r\n\t\t\t\r\n\t\t\tvar localLinkX = linkGapX*Math.cos(-wallAng) - linkGapZ*Math.sin(-wallAng);\r\n\t\t\t//var localLinkZ = linkGapX*Math.sin(-wallAng) + linkGapZ*Math.cos(-wallAng);\r\n\t\t\t\r\n\t\t\tvar doorHalf = doorlinkEl.components.doorlink.data.width / 2;\r\n\t\t\tlocalLinkX = Math.max(localLinkX,doorHalf+HAIR);\r\n\t\t\tlocalLinkX = Math.min(localLinkX,wallLength-doorHalf-HAIR);\r\n\t\t\t\r\n\t\t\tdoorholeEl.setAttribute(\"position\",{x:localLinkX,y:0,z:0});\r\n\t\t\tdoorholeEl.object3D.updateMatrixWorld();\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tfunction getHoleLink(doorholeEl){\r\n\t\t\tvar doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\r\n\t\t\tfor(var curLinkIndex=0; curLinkIndex<doorlinks.length; curLinkIndex++){\r\n\t\t\t\tvar curLink = doorlinks[curLinkIndex];\r\n\t\t\t\tif (curLink.components.doorlink.data.from == doorholeEl) return curLink;\r\n\t\t\t\tif (curLink.components.doorlink.data.to   == doorholeEl) return curLink;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfunction getWallHeight(wallEl){\r\n\t\t\tif (wallEl.components.wall.data.height) return wallEl.components.wall.data.height;\r\n\t\t\treturn wallEl.parentNode.components.room.data.height;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tif (buildingSelf.dirty) return;\r\n\t\tbuildingSelf.dirty = true;\r\n\t\tsetTimeout(function(){\r\n\t\t\t\r\n\t\t\t//console.log(\" == STARTING RE-EVALUATION...\");\r\n\t\t\t\r\n\t\t\t// silly but necessary because of threeJS weirdness\r\n\t\t\tbuildingSelf.el.object3D.updateMatrixWorld();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// lay out walls' angles:\r\n\t\t\t\r\n\t\t\tfor(var sceneChildNodeIndex=0; sceneChildNodeIndex<buildingSelf.el.children.length; sceneChildNodeIndex++){\r\n\t\t\t\tvar sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\r\n\t\t\t\tif (sceneChildNode.components && sceneChildNode.components.room) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar w = sceneChildNode.components.room.data.width;\r\n\t\t\t\t\tvar l = sceneChildNode.components.room.data.length;\r\n\t\t\t\t\tif (w || l) {\r\n\t\t\t\t\t\tif (w && l) {\r\n\t\t\t\t\t\t\tvar rawWalls = getUnsortedRoomWallArray(sceneChildNode);\r\n\t\t\t\t\t\t\tif (rawWalls.length >= 4) {\r\n\t\t\t\t\t\t\t\tif (rawWalls.length > 4) console.error(\"rooms with WIDTH and LENGTH should only have four walls!\");\r\n\t\t\t\t\t\t\t\trawWalls[0].setAttribute(\"position\",{x:0,y:0,z:0});\r\n\t\t\t\t\t\t\t\trawWalls[1].setAttribute(\"position\",{x:w,y:0,z:0});\r\n\t\t\t\t\t\t\t\trawWalls[2].setAttribute(\"position\",{x:w,y:0,z:l});\r\n\t\t\t\t\t\t\t\trawWalls[3].setAttribute(\"position\",{x:0,y:0,z:l});\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tconsole.error(\"rooms with WIDTH and LENGTH must have four walls!\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tconsole.error(\"rooms with WIDTH must also have LENGTH (and vice versa)\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar walls=getRoomWallArray(sceneChildNode);\r\n\t\t\t\t\tif (walls.length > 2) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor(var wallIndex=0; wallIndex<walls.length; wallIndex++){\r\n\t\t\t\t\t\t\tvar curWallNode = walls[wallIndex];\r\n\t\t\t\t\t\t\tvar nextWallNode = walls[(wallIndex+1)%walls.length];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\r\n\t\t\t\t\t\t\tvar wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\r\n\t\t\t\t\t\t\tvar wallAng = Math.atan2(wallGapZ,wallGapX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tcurWallNode.setAttribute(\"rotation\",{x:0,y:-wallAng/Math.PI*180,z:0});\r\n\t\t\t\t\t\t\tcurWallNode.object3D.updateMatrixWorld();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// position the door holes:\r\n\t\t\t\r\n\t\t\tvar doorlinks = buildingSelf.el.querySelectorAll('[doorlink]');\r\n\t\t\tfor(var curDoorlinkElIndex=0; curDoorlinkElIndex<doorlinks.length; curDoorlinkElIndex++){\r\n\t\t\t\tvar curDoorlinkEl = doorlinks[curDoorlinkElIndex];\r\n\t\t\t\tvar curDoorlink = curDoorlinkEl.components.doorlink;\r\n\t\t\t\tif (!curDoorlink) return;//still setting up, try again later\r\n\t\t\t\t\r\n\t\t\t\tmoveForLink(curDoorlink.data.from,curDoorlink.el);\r\n\t\t\t\tmoveForLink(curDoorlink.data.to,curDoorlink.el);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// generate the walls' geometry:\r\n\t\t\t\r\n\t\t\tfor(var sceneChildNodeIndex=0; sceneChildNodeIndex<buildingSelf.el.children.length; sceneChildNodeIndex++){\r\n\t\t\t\tvar sceneChildNode = buildingSelf.el.children[sceneChildNodeIndex];\r\n\t\t\t\tif (sceneChildNode.components && sceneChildNode.components.room) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar isOutside = sceneChildNode.components.room.data.outside;\r\n\t\t\t\t\tvar walls=getRoomWallArray(sceneChildNode);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (walls.length > 2) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor(var wallIndex=0; wallIndex<walls.length; wallIndex++){\r\n\t\t\t\t\t\t\tvar curWallNode = walls[wallIndex];\r\n\t\t\t\t\t\t\tvar nextWallNode = walls[(wallIndex+1)%walls.length];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar wallGapX = nextWallNode.components.position.data.x - curWallNode.components.position.data.x;\r\n\t\t\t\t\t\t\tvar wallGapZ = nextWallNode.components.position.data.z - curWallNode.components.position.data.z;\r\n\t\t\t\t\t\t\tvar wallLength = Math.sqrt(wallGapX*wallGapX + wallGapZ*wallGapZ);\r\n\t\t\t\t\t\t\tvar wallAng = Math.atan2(wallGapZ,wallGapX);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar wallGapY = nextWallNode.components.position.data.y - curWallNode.components.position.data.y;\r\n\t\t\t\t\t\t\tvar heightGap = getWallHeight(nextWallNode) - getWallHeight(curWallNode);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar orderedHoles=[];\r\n\t\t\t\t\t\t\tfor(var wallChildNodeIndex=0; wallChildNodeIndex<curWallNode.children.length; wallChildNodeIndex++){\r\n\t\t\t\t\t\t\t\tvar wallChildNode = curWallNode.children[wallChildNodeIndex];\r\n\t\t\t\t\t\t\t\tif (wallChildNode.components && wallChildNode.components.doorhole) {\r\n\t\t\t\t\t\t\t\t\torderedHoles.push(wallChildNode);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\torderedHoles.sort(function(a,b){\r\n\t\t\t\t\t\t\t\treturn a.components.position.data.x - b.components.position.data.x;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar wallShape = new THREE.Shape();\r\n\t\t\t\t\t\t\twallShape.moveTo(\r\n\t\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t\tgetWallHeight(curWallNode)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\twallShape.lineTo(\r\n\t\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t\t0\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor(var holeIndex=0; holeIndex<orderedHoles.length; holeIndex++){\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tvar holeEl = orderedHoles[holeIndex];\r\n\t\t\t\t\t\t\t\tif (!holeEl.myVerts) holeEl.myVerts = [];\r\n\t\t\t\t\t\t\t\tholeEl.myVerts.length=0;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tvar linkEl = getHoleLink(orderedHoles[holeIndex]);\r\n\t\t\t\t\t\t\t\tif (!linkEl) continue;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tvar holeInfo = holeEl.components;\r\n\t\t\t\t\t\t\t\tvar linkInfo = linkEl.components;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tfor(var holeSide=-1; holeSide<=1; holeSide+=2){\r\n\t\t\t\t\t\t\t\t\tvar ptX = holeInfo.position.data.x + linkInfo.doorlink.data.width/2*holeSide;\r\n\t\t\t\t\t\t\t\t\tvar floorY = (ptX/wallLength)*wallGapY;\r\n\t\t\t\t\t\t\t\t\tvar topY = floorY + linkInfo.doorlink.data.height;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tvar curCeil = getWallHeight(curWallNode) + (ptX/wallLength)*heightGap;\r\n\t\t\t\t\t\t\t\t\tvar maxTopY = floorY + curCeil - HAIR;//will always be a seam, but, I'm not bothering to rewrite just for that\r\n\t\t\t\t\t\t\t\t\tif (topY > maxTopY) topY = maxTopY;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tfunction addWorldVert(ptY){\r\n\t\t\t\t\t\t\t\t\t\tvar tempPos = new THREE.Vector3(ptX,ptY,0);\r\n\t\t\t\t\t\t\t\t\t\tcurWallNode.object3D.localToWorld(tempPos);\r\n\t\t\t\t\t\t\t\t\t\tholeEl.myVerts.push(tempPos);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\taddWorldVert(floorY);\r\n\t\t\t\t\t\t\t\t\taddWorldVert(topY);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif (holeSide < 0) {\r\n\t\t\t\t\t\t\t\t\t\twallShape.lineTo(ptX,floorY);\r\n\t\t\t\t\t\t\t\t\t\twallShape.lineTo(ptX,topY);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\twallShape.lineTo(ptX,topY);\r\n\t\t\t\t\t\t\t\t\t\twallShape.lineTo(ptX,floorY);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\twallShape.lineTo(\r\n\t\t\t\t\t\t\t\twallLength,\r\n\t\t\t\t\t\t\t\tnextWallNode.components.position.data.y-curWallNode.components.position.data.y\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\twallShape.lineTo(\r\n\t\t\t\t\t\t\t\twallLength,\r\n\t\t\t\t\t\t\t\t(nextWallNode.components.position.data.y-curWallNode.components.position.data.y)+getWallHeight(nextWallNode)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar wallGeom = new THREE.ShapeGeometry(wallShape);\r\n\t\t\t\t\t\t\tmakePlaneUvs(wallGeom,'x','y',1,1);\r\n\t\t\t\t\t\t\tfinishGeom(wallGeom);\r\n\t\t\t\t\t\t\tvar myMat = curWallNode.components.material ? curWallNode.components.material.material : curWallNode.parentNode.components.material.material;\r\n\t\t\t\t\t\t\tif (curWallNode.myMesh) {\r\n\t\t\t\t\t\t\t\tcurWallNode.myMesh.geometry = wallGeom;\r\n\t\t\t\t\t\t\t\tcurWallNode.myMesh.material = myMat;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcurWallNode.myMesh = new THREE.Mesh(wallGeom, myMat);\r\n\t\t\t\t\t\t\t\tcurWallNode.setObject3D('wallMesh',curWallNode.myMesh);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar caps=[];\r\n\t\t\t\t\t\tfor(var roomChildNodeIndex=0; roomChildNodeIndex<sceneChildNode.children.length; roomChildNodeIndex++){\r\n\t\t\t\t\t\t\tvar roomChildNode = sceneChildNode.children[roomChildNodeIndex];\r\n\t\t\t\t\t\t\tif (roomChildNode.components) {\r\n\t\t\t\t\t\t\t\tif (roomChildNode.components.floor || roomChildNode.components.ceiling) caps.push(roomChildNode);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(var curCapNodeIndex=0; curCapNodeIndex<caps.length; curCapNodeIndex++){\r\n\t\t\t\t\t\t\tvar curCapNode = caps[curCapNodeIndex];\r\n\t\t\t\t\t\t\tvar isCeiling = curCapNode.components.ceiling;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar capShape = new THREE.Shape();\r\n\t\t\t\t\t\t\tfor(var wallIndex=0; wallIndex<walls.length; wallIndex++){\r\n\t\t\t\t\t\t\t\tvar curWallNode = walls[wallIndex];\r\n\t\t\t\t\t\t\t\tvar ptX = curWallNode.components.position.data.x;\r\n\t\t\t\t\t\t\t\tvar ptZ = curWallNode.components.position.data.z;\r\n\t\t\t\t\t\t\t\tif (wallIndex) {\r\n\t\t\t\t\t\t\t\t\tcapShape.lineTo(ptX,ptZ);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcapShape.moveTo(ptX,ptZ);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar capGeom = new THREE.ShapeGeometry(capShape);\r\n\t\t\t\t\t\t\tfor(var wallIndex=0; wallIndex<walls.length; wallIndex++){\r\n\t\t\t\t\t\t\t\tvar curWallNode = walls[wallIndex];\r\n\t\t\t\t\t\t\t\tvar curVert = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\t\tcapGeom.attributes.position.getX(wallIndex),\r\n\t\t\t\t\t\t\t\t\tcapGeom.attributes.position.getY(wallIndex),\r\n\t\t\t\t\t\t\t\t\tcapGeom.attributes.position.getZ(wallIndex)\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\tcurVert.set(curVert.x,curWallNode.components.position.data.y,curVert.y);\r\n\t\t\t\t\t\t\t\tif (isCeiling) curVert.y += getWallHeight(curWallNode);\r\n\t\t\t\t\t\t\t\tcapGeom.attributes.position.setXYZ(wallIndex,curVert.x,curVert.y,curVert.z);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar shouldReverse = false;\r\n\t\t\t\t\t\t\tif (!isCeiling) shouldReverse = !shouldReverse;\r\n\t\t\t\t\t\t\tif (isOutside)  shouldReverse = !shouldReverse;\r\n\t\t\t\t\t\t\tif (shouldReverse) flipGeom(capGeom);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tmakePlaneUvs(capGeom,'x','z',isCeiling?1:-1,1);\r\n\t\t\t\t\t\t\tfinishGeom(capGeom);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (!curCapNode.myMeshes) curCapNode.myMeshes=[];\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar typeLabel = isCeiling?\"ceiling\":\"floor\";\r\n\t\t\t\t\t\t\tvar myMat = curCapNode.components.material ? curCapNode.components.material.material : curCapNode.parentNode.components.material.material;\r\n\t\t\t\t\t\t\tif (curCapNode.myMeshes[typeLabel]) {\r\n\t\t\t\t\t\t\t\tcurCapNode.myMeshes[typeLabel].geometry = capGeom;\r\n\t\t\t\t\t\t\t\tcurCapNode.myMeshes[typeLabel].material = myMat;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcurCapNode.myMeshes[typeLabel] = new THREE.Mesh(capGeom, myMat);\r\n\t\t\t\t\t\t\t\tcurCapNode.setObject3D(typeLabel,curCapNode.myMeshes[typeLabel]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// generate the door tunnels' geometry:\r\n\t\t\t\r\n\t\t\tfor(var curDoorlinkElIndex=0; curDoorlinkElIndex<doorlinks.length; curDoorlinkElIndex++){\r\n\t\t\t\tvar curDoorlinkEl = doorlinks[curDoorlinkElIndex];\r\n\t\t\t\t\r\n\t\t\t\tvar curDoorlink = curDoorlinkEl.components.doorlink;\r\n\t\t\t\tif (!curDoorlink.data.from) continue;\r\n\t\t\t\tif (!curDoorlink.data.to) continue;\r\n\t\t\t\tif (!curDoorlink.data.from.myVerts) return;\r\n\t\t\t\tif (!curDoorlink.data.to.myVerts) return;\r\n\t\t\t\t\r\n\t\t\t\tfor(var doorLinkChildIndex=0; doorLinkChildIndex<curDoorlinkEl.children.length; doorLinkChildIndex++){\r\n\t\t\t\t\tvar doorLinkChild = curDoorlinkEl.children[doorLinkChildIndex];\r\n\t\t\t\t\tif (!doorLinkChild.components) continue;\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar types=[\"sides\",\"floor\",\"ceiling\"];\r\n\t\t\t\t\tfor(var curTypeIndex=0; curTypeIndex<types.length; curTypeIndex++){\r\n\t\t\t\t\t\tvar curType = types[curTypeIndex];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (!doorLinkChild.components[curType]) continue;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar myMat = doorLinkChild.components.material?doorLinkChild.components.material.material:doorLinkChild.parentNode.components.material.material;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (!doorLinkChild.myGeoms) doorLinkChild.myGeoms=[];\r\n\t\t\t\t\t\tif (!doorLinkChild.myGeoms[curType]) {\r\n\t\t\t\t\t\t\tvar curGeom = new THREE.BufferGeometry();\r\n\t\t\t\t\t\t\tdoorLinkChild.myGeoms[curType] = curGeom;\r\n\t\t\t\t\t\t\tvar myMesh = new THREE.Mesh(\r\n\t\t\t\t\t\t\t\tcurGeom,\r\n\t\t\t\t\t\t\t\tmyMat\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcurGeom.meshRef = myMesh;\r\n\t\t\t\t\t\t\tdoorLinkChild.setObject3D(curType,myMesh);\r\n\t\t\t\t\t\t\tvar indexArray = [];\r\n\t\t\t\t\t\t\tindexArray.push( 0,1,2, 1,3,2 );\r\n\t\t\t\t\t\t\tif (curType==\"sides\") indexArray.push( 4,5,6, 5,7,6 );\r\n\t\t\t\t\t\t\tcurGeom.setIndex(indexArray);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar curGeom = doorLinkChild.myGeoms[curType];\r\n\t\t\t\t\t\tcurGeom.meshRef.material = myMat;\r\n\t\t\t\t\t\tvar positionArray = [];\r\n\t\t\t\t\t\tfunction addWorldVertex(pt){\r\n\t\t\t\t\t\t\tvar localPt = pt.clone();\r\n\t\t\t\t\t\t\tdoorLinkChild.object3D.worldToLocal(localPt);\r\n\t\t\t\t\t\t\tpositionArray.push(localPt.x,localPt.y,localPt.z);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfunction commitVertices(){\r\n\t\t\t\t\t\t\tcurGeom.setAttribute('position',new THREE.BufferAttribute(new Float32Array(positionArray),3));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar fVerts=curDoorlink.data.from.myVerts;\r\n\t\t\t\t\t\tvar tVerts=curDoorlink.data.to.myVerts;\r\n\t\t\t\t\t\tswitch(curType){\r\n\t\t\t\t\t\t\tcase \"floor\":\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\taddWorldVertex(tVerts[0]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(tVerts[2]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(fVerts[2]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(fVerts[0]);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tcommitVertices();\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmakeUvsForGeom(curGeom,function(pt,vertIndex){\r\n\t\t\t\t\t\t\t\t\treturn [\r\n\t\t\t\t\t\t\t\t\t\t1-(vertIndex%2),\r\n\t\t\t\t\t\t\t\t\t\t1-Math.floor(vertIndex/2)\r\n\t\t\t\t\t\t\t\t\t];\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"ceiling\":\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\taddWorldVertex(tVerts[3]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(tVerts[1]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(fVerts[1]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(fVerts[3]);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tcommitVertices();\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmakeUvsForGeom(curGeom,function(pt,vertIndex){\r\n\t\t\t\t\t\t\t\t\treturn [\r\n\t\t\t\t\t\t\t\t\t\tvertIndex%2,\r\n\t\t\t\t\t\t\t\t\t\t1-Math.floor(vertIndex/2)\r\n\t\t\t\t\t\t\t\t\t];\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase \"sides\":\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\taddWorldVertex(tVerts[2]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(tVerts[3]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(fVerts[0]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(fVerts[1]);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\taddWorldVertex(fVerts[2]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(fVerts[3]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(tVerts[0]);\r\n\t\t\t\t\t\t\t\taddWorldVertex(tVerts[1]);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tcommitVertices();\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmakeUvsForGeom(curGeom,function(pt,vertIndex){\r\n\t\t\t\t\t\t\t\t\tvar uv = [];\r\n\t\t\t\t\t\t\t\t\tuv[0] = Math.floor(vertIndex/2);\r\n\t\t\t\t\t\t\t\t\tuv[1] = vertIndex%2;\r\n\t\t\t\t\t\t\t\t\tif (vertIndex<4) uv[0] = 1-uv[0];\r\n\t\t\t\t\t\t\t\t\treturn uv;\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfinishGeom(curGeom);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//console.log(\" === RE-EVALUATION COMPLETE!\");\r\n\t\t\tbuildingSelf.dirty = false;\r\n\t\t\t\r\n\t\t});\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n});\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction updateScene(lastScene){\r\n\tif (lastScene && lastScene.systems.building) lastScene.systems.building.reexamineBuilding();\r\n}\r\nfunction positionWatch(e){\r\n\tif (e.detail.name == \"position\") updateScene(e.detail.target.sceneEl);\r\n}\r\n\r\nfunction nodeSceneInit(){\r\n\tthis.lastScene = this.el.sceneEl;\r\n\tupdateScene(this.lastScene);\r\n\tthis.el.addEventListener('componentchanged',positionWatch);\r\n}\r\nfunction nodeSceneUpdate(){\r\n\tupdateScene(this.lastScene);\r\n}\r\nfunction nodeSceneRemove(){\r\n\tupdateScene(this.lastScene);\r\n\tthis.lastScene = null;\r\n\tthis.el.removeEventListener('componentchanged',positionWatch);\r\n}\r\n\r\n\r\nvar refreshSceneConfig = {\r\n\tinit:nodeSceneInit,\r\n\tupdate:nodeSceneUpdate,\r\n\tremove:nodeSceneRemove\r\n};\r\n\r\n\r\n\r\nAFRAME.registerComponent('room',Object.assign({\r\n\t\r\n\tschema:{\r\n\t\toutside:{type:'boolean'},\r\n\t\theight:{type:'number', default:2.4},\r\n\t\twidth:{type:'number'},\r\n\t\tlength:{type:'number'}\r\n\t},\r\n\t\r\n},refreshSceneConfig));\r\n\r\nAFRAME.registerComponent('wall',Object.assign({\r\n\t\r\n\tschema:{\r\n\t\theight:{type:'number'},\r\n\t}\r\n\t\r\n},refreshSceneConfig));\r\n\r\nAFRAME.registerComponent('floor',refreshSceneConfig);\r\nAFRAME.registerComponent('ceiling',refreshSceneConfig);\r\n\r\n\r\nAFRAME.registerComponent('doorhole',refreshSceneConfig);\r\n\r\nAFRAME.registerComponent('doorlink',Object.assign({\r\n\t\r\n\tschema:{\r\n\t\tfrom:{type:'selector'},\r\n\t\tto:{type:'selector'},\r\n\t\theight:{type:'number', default:2.0},\r\n\t\twidth:{type:'number', default:0.8}\r\n\t}\r\n\t\r\n},refreshSceneConfig));\r\n\r\nAFRAME.registerComponent('sides',refreshSceneConfig);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// could probably automate this rather than hard-coding it, but this'll do for now:\r\n\r\nAFRAME.registerPrimitive('rw-room',{\r\n\tdefaultComponents:{room:{}},\r\n\tmappings:{\r\n\t\toutside:'room.outside',\r\n\t\theight:'room.height',\r\n\t\twidth:'room.width',\r\n\t\tlength:'room.length'\r\n\t}\r\n});\r\n\r\nAFRAME.registerPrimitive('rw-wall',{\r\n\tdefaultComponents:{wall:{}},\r\n\tmappings:{\r\n\t\theight:'wall.height'\r\n\t}\r\n});\r\n\r\nAFRAME.registerPrimitive('rw-floor',{\r\n\tdefaultComponents:{floor:{}},\r\n\tmappings:{}\r\n});\r\n\r\nAFRAME.registerPrimitive('rw-ceiling',{\r\n\tdefaultComponents:{ceiling:{}},\r\n\tmappings:{}\r\n});\r\n\r\nAFRAME.registerPrimitive('rw-doorhole',{\r\n\tdefaultComponents:{doorhole:{}},\r\n\tmappings:{}\r\n});\r\n\r\nAFRAME.registerPrimitive('rw-doorlink',{\r\n\tdefaultComponents:{doorlink:{}},\r\n\tmappings:{\r\n\t\tfrom:'doorlink.from',\r\n\t\tto:'doorlink.to',\r\n\t\theight:'doorlink.height',\r\n\t\twidth:'doorlink.width',\r\n\t}\r\n});\r\n\r\nAFRAME.registerPrimitive('rw-sides',{\r\n\tdefaultComponents:{sides:{}},\r\n\tmappings:{}\r\n});\r\n\r\n\r\n\r\n\r\n\r\n"],"names":["root","factory","exports","module","define","amd","a","i","self","updateScene","lastScene","systems","building","reexamineBuilding","positionWatch","e","detail","name","target","sceneEl","AFRAME","registerSystem","buildingSelf","this","HAIR","flipGeom","geom","indices","getIndex","array","length","tempIndex","needsUpdate","makeUvsForGeom","callback","allUVs","faceVertIndex","index","vertexIndex","uv","THREE","Vector3","attributes","position","getX","getY","getZ","setAttribute","BufferAttribute","Float32Array","uvsNeedUpdate","makePlaneUvs","uKey","vKey","uMult","vMult","pt","finishGeom","computeVertexNormals","computeBoundingBox","computeBoundingSphere","getUnsortedRoomWallArray","roomEl","walls","roomChildNodeIndex","children","roomChildNode","components","wall","push","getRoomWallArray","isOutside","room","data","outside","cwSum","wallIndex","curWallNode","nextWallNode","curWallPos","nextWallPos","x","z","shouldReverse","reverse","worldWallPos","worldNextPos","worldLinkPos","moveForLink","doorholeEl","doorlinkEl","wallEl","wallList","curWallIndex","holeWallEl","parentNode","nextWallEl","indexOf","object3D","getWorldPosition","linkGapX","linkGapZ","wallGapX","wallGapZ","wallAng","Math","atan2","wallLength","sqrt","localLinkX","cos","sin","doorHalf","doorlink","width","max","min","y","updateMatrixWorld","getHoleLink","doorlinks","el","querySelectorAll","curLinkIndex","curLink","from","to","getWallHeight","height","dirty","setTimeout","sceneChildNodeIndex","sceneChildNode","w","l","rawWalls","console","error","PI","curDoorlinkElIndex","curDoorlinkEl","curDoorlink","wallGapY","heightGap","orderedHoles","wallChildNodeIndex","wallChildNode","doorhole","sort","b","wallShape","Shape","moveTo","lineTo","holeIndex","holeEl","myVerts","linkEl","holeInfo","linkInfo","_loop","addWorldVert","ptY","tempPos","ptX","localToWorld","holeSide","topY","floorY","curCeil","maxTopY","wallGeom","ShapeGeometry","myMat","material","myMesh","geometry","Mesh","setObject3D","caps","floor","ceiling","curCapNodeIndex","curCapNode","isCeiling","capShape","ptZ","capGeom","curVert","set","setXYZ","myMeshes","typeLabel","doorLinkChildIndex","doorLinkChild","types","_loop2","curType","curTypeIndex","addWorldVertex","localPt","clone","worldToLocal","positionArray","commitVertices","curGeom","myGeoms","BufferGeometry","meshRef","indexArray","setIndex","fVerts","tVerts","vertIndex","refreshSceneConfig","init","addEventListener","update","remove","removeEventListener","registerComponent","Object","assign","schema","type","default","registerPrimitive","defaultComponents","mappings","sides"],"sourceRoot":""}